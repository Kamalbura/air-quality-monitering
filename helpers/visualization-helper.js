/**
 * Helper for generating visualizations with secure file handling
 * Improved with better memory management and error handling
 */
const fs = require('fs');
const path = require('path');
const os = require('os');
const crypto = require('crypto');
const { PythonShell } = require('python-shell');
const thingspeakService = require('../services/thingspeak-service');
const debugHelper = require('./debug-helper');

// Create a more limited cache with TTL to prevent memory leaks
const LRU = require('lru-cache');
const visualizationCache = new LRU({
  max: 50,                    // Store max 50 visualizations
  maxAge: 1000 * 60 * 30,     // Items expire after 30 minutes  
  updateAgeOnGet: true,       // Reset TTL when accessed
  dispose: (key, value) => {  // Clean up image files when removed from cache
    try {
      if (value && value.imagePath) {
        const fullPath = path.join(__dirname, '..', 'public', value.imagePath);
        if (fs.existsSync(fullPath) && 
            fullPath.includes('temp_') && 
            !fullPath.includes('error.png')) {
          fs.unlinkSync(fullPath);
          debugHelper.log(`Removed cached visualization: ${fullPath}`, 'visualization-cache');
        }
      }
    } catch (e) {
      console.error('Error cleaning up visualization:', e);
    }
  }
});

/**
 * Generate a secure temporary file path with sanitization
 * @param {string} prefix - File prefix
 * @param {string} extension - File extension
 * @returns {string} Temporary file path
 */
function generateTempFilePath(prefix, extension) {
  // Sanitize inputs
  const safePrefix = prefix.replace(/[^a-z0-9_-]/gi, '_').substring(0, 20);
  const safeExt = extension.replace(/[^a-z0-9]/gi, '').substring(0, 10);
  
  const randomString = crypto.randomBytes(8).toString('hex');
  const timestamp = Date.now();
  return path.join(os.tmpdir(), `${safePrefix}_${timestamp}_${randomString}.${safeExt}`);
}

/**
 * Ensure directory exists before writing files
 * @param {string} directory - Directory path
 */
function ensureDirectoryExists(directory) {
  if (!fs.existsSync(directory)) {
    fs.mkdirSync(directory, { recursive: true });
  }
}

/**
 * Ensure error image exists or create a placeholder
 * @returns {string} Path to error image
 */
function ensureErrorImageExists() {
  const errorImagePath = path.join(__dirname, '..', 'public', 'images', 'error.png');
  const errorImageWebPath = '/images/error.png';
  
  // Ensure directory exists first
  ensureDirectoryExists(path.dirname(errorImagePath));
  
  // Check if error image exists, create a simple one if not
  if (!fs.existsSync(errorImagePath)) {
    try {
      // Try to copy a default error image if it exists
      const defaultErrorImage = path.join(__dirname, '..', 'public', 'images', 'default_error.png');
      if (fs.existsSync(defaultErrorImage)) {
        fs.copyFileSync(defaultErrorImage, errorImagePath);
      } else {
        // Create a placeholder error image file - future improvement: generate a proper image
        fs.writeFileSync(errorImagePath, 'ERROR_IMAGE_PLACEHOLDER');
      }
      console.log('Created error image:', errorImagePath);
    } catch (err) {
      console.error('Failed to create error image:', err);
    }
  }
  
  return errorImageWebPath;
}

/**
 * Find appropriate Python visualization script with security validation
 * @param {string} type - Visualization type
 * @returns {Object} Script info
 */
function findVisualizationScript(type) {
  // Sanitize the type parameter to prevent path traversal
  const safeType = type.replace(/[^a-z0-9_-]/gi, '');
  
  const pythonDir = path.join(__dirname, '..', 'python');
  
  // Check if specific script exists for this visualization type
  const specificScript = path.join(pythonDir, `${safeType}.py`);
  if (fs.existsSync(specificScript)) {
    return { path: specificScript, name: `${safeType}.py`, exists: true };
  }
  
  // Check for visualization.py
  const generalScript = path.join(pythonDir, 'visualization.py');
  if (fs.existsSync(generalScript)) {
    return { path: generalScript, name: 'visualization.py', exists: true };
  }
  
  return { path: null, name: null, exists: false };
}

/**
 * Generate visualization for air quality data with improved error handling and caching
 */
async function generateVisualization(type, options = {}) {
  console.log(`Generating visualization for type: ${type}`);
  
  // Special case for standard visualizations that are always generated by analysis.py
  if (type === 'time_series' || type === 'pm25_trend' || type === 'standard') {
    // If type is standard, default to time_series
    const actualType = type === 'standard' ? 'time_series' : type;
    const imagePath = actualType === 'time_series' ? '/images/time_series.png' : '/images/pm25_trend.png';
    
    // Check if the image exists
    const fullImagePath = path.join(__dirname, '..', 'public', imagePath);
    console.log(`Checking if image exists at: ${fullImagePath}`);
    
    if (!fs.existsSync(fullImagePath)) {
      console.log(`Standard visualization not found at ${fullImagePath}, generating...`);
      
      // Run the analysis script to generate the visualizations if they don't exist
      try {
        const pyOptions = {
          mode: 'text',  // CHANGE: Use text mode instead of JSON
          pythonPath: process.env.PYTHON_PATH || 'python',
          scriptPath: path.join(__dirname, '..', 'python'),
          args: [
            options.dataPath || path.join(__dirname, '..', 'data', 'air_quality_data.csv'),
            options.startDate || '',
            options.endDate || ''
          ]
        };
        
        console.log(`Running Python analysis with options: ${JSON.stringify(pyOptions)}`);
        
        await PythonShell.run('analysis.py', pyOptions);
        
        // Check again if the file was created
        if (!fs.existsSync(fullImagePath)) {
          console.error(`Image still not found after Python script execution: ${fullImagePath}`);
          throw new Error(`Failed to generate ${actualType} visualization`);
        }
        
        console.log(`Successfully generated visualization: ${fullImagePath}`);
      } catch (error) {
        console.error(`Error generating ${actualType} visualization:`, error);
        return {
          success: false,
          error: error.message,
          data: {
            imagePath: ensureErrorImageExists(),
            description: `Error generating ${actualType} visualization: ${error.message}`
          }
        };
      }
    } else {
      console.log(`Found existing visualization at: ${fullImagePath}`);
    }
    
    // Get description based on type
    let description;
    if (actualType === 'time_series') {
      description = "Time series analysis showing PM2.5 and PM10 levels over time, with WHO guideline thresholds.";
    } else {
      description = "PM2.5 trend analysis with rolling average to show patterns over time.";
    }
    
    return {
      success: true,
      data: {
        imagePath,
        description,
        dataSource: 'Standard visualization from analysis.py'
      }
    };
  }
  
  // For other visualization types, use the existing implementation
  const validTypes = ['daily_pattern', 'heatmap', 'correlation', 'standard'];
  if (!validTypes.includes(type)) {
    console.log(`Invalid visualization type requested: ${type}`);
    return {
      success: false,
      error: `Unsupported visualization type: ${type}`,
      data: {
        imagePath: ensureErrorImageExists(),
        description: `The visualization type "${type}" is not supported.`
      }
    };
  }

  // Create cache key from type and options
  const cacheKey = `${type}_${JSON.stringify({
    startDate: options.startDate || '',
    endDate: options.endDate || '',
    sampling: options.sampling || 1000
  })}`;
  
  // Check if we have a cached result
  if (visualizationCache.has(cacheKey)) {
    console.log(`Using cached visualization for ${type}`);
    return { 
      success: true, 
      data: visualizationCache.get(cacheKey) 
    };
  }

  // Track temp files for cleanup
  const tempFiles = new Set();
  
  // Cleanup handler function
  const cleanupHandler = () => {
    tempFiles.forEach(file => {
      try {
        if (fs.existsSync(file)) {
          fs.unlinkSync(file);
          console.log(`Cleaned up temporary file: ${file}`);
        }
      } catch (e) {
        console.error(`Error cleaning up temp file ${file}:`, e.message);
      }
    });
  };
  
  // Register cleanup handlers
  process.on('exit', cleanupHandler);
  const exitHandler = () => { 
    cleanupHandler(); 
    process.exit(1); 
  };
  process.once('SIGINT', exitHandler);
  process.once('uncaughtException', exitHandler);
  
  try {
    // Find appropriate script
    const scriptInfo = findVisualizationScript(type);
    if (!scriptInfo.exists) {
      console.log(`No visualization script found for type: ${type}`);
      const result = {
        success: false,
        error: 'Visualization script not found',
        data: {
          imagePath: ensureErrorImageExists(),
          description: `Could not find a Python script to generate ${type} visualization.`,
        },
        clientSide: true  // Signal that client-side rendering should be used
      };
      return result;
    }
    
    // Get data from ThingSpeak with retry logic
    console.log(`Fetching data for ${type} visualization, sampling: ${options.sampling || 1000}`);
    let result;
    let retries = 3;
    
    while (retries > 0) {
      try {
        result = await thingspeakService.getChannelData({
          results: Math.min(options.sampling || 1000, 10000), // Cap at 10,000 to prevent memory issues
          start: options.startDate,
          end: options.endDate
        });
        if (result && result.data && result.data.length > 0) {
          break;
        }
        retries--;
      } catch (error) {
        console.error(`Data fetch attempt failed (${retries} retries left):`, error);
        retries--;
        if (retries === 0) throw error;
        // Wait a bit before retrying
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
    
    if (!result || !result.data || result.data.length === 0) {
      console.log('No data available for visualization');
      return {
        success: false,
        error: 'No data available for visualization',
        data: {
          imagePath: ensureErrorImageExists(),
          description: 'No data available for the selected date range.',
        },
        clientSide: true  // Signal that client-side rendering should be used
      };
    }
    
    // For large datasets, create data in chunks to avoid memory issues
    const dataPoints = result.data.length;
    console.log(`Retrieved ${dataPoints} data points for visualization`);
    
    // Memory efficient CSV creation - use streaming for large datasets
    let tempCsvPath = '';
    
    // Check data size and use appropriate method
    if (dataPoints > 5000) {
      // Use streaming for large datasets
      tempCsvPath = generateTempFilePath('viz_data', 'csv');
      tempFiles.add(tempCsvPath);
      
      const writeStream = fs.createWriteStream(tempCsvPath);
      // Write header
      writeStream.write('created_at,field1,field2,field3,field4\n');
      
      // Write data in small batches
      const batchSize = 1000;
      for (let i = 0; i < result.data.length; i += batchSize) {
        const batch = result.data.slice(i, i + batchSize);
        let batchContent = '';
        
        batch.forEach(item => {
          batchContent += `${item.created_at},${item.humidity || item.field1},${item.temperature || item.field2},${item.pm25 || item.field3},${item.pm10 || item.field4}\n`;
        });
        
        // Wait for backpressure to be resolved if needed
        if (!writeStream.write(batchContent)) {
          await new Promise(resolve => writeStream.once('drain', resolve));
        }
        
        // Allow event loop to process other tasks
        await new Promise(resolve => setTimeout(resolve, 0));
      }
      
      // Close the stream and wait for finish
      await new Promise((resolve, reject) => {
        writeStream.end();
        writeStream.on('finish', resolve);
        writeStream.on('error', reject);
      });
      
    } else {
      // For smaller datasets, use the simpler approach
      tempCsvPath = generateTempFilePath('viz_data', 'csv');
      tempFiles.add(tempCsvPath);
      
      let csvContent = 'created_at,field1,field2,field3,field4\n';
      result.data.forEach(item => {
        csvContent += `${item.created_at},${item.humidity || item.field1},${item.temperature || item.field2},${item.pm25 || item.field3},${item.pm10 || item.field4}\n`;
      });
      
      fs.writeFileSync(tempCsvPath, csvContent);
    }
    
    console.log(`Created temp CSV file: ${tempCsvPath} with ${dataPoints} rows`);
    
    // Setup Python options with sanitized inputs
    const pyOptions = {
      mode: 'text',
      scriptPath: path.dirname(scriptInfo.path),
      args: [
        tempCsvPath,
        type,
        options.startDate || '',
        options.endDate || '',
        String(Math.min(options.sampling || 1000, 10000))  // Cap at 10,000
      ],
      pythonOptions: ['-u'],  // Unbuffered output for better logging
      pythonPath: process.env.PYTHON_PATH || 'python' // Allow custom Python path
    };
    
    // Run Python script with a timeout
    const timeoutMs = dataPoints > 5000 ? 60000 : 30000; // 60s for large datasets, 30s otherwise
    
    const vizResult = await new Promise((resolve, reject) => {
      let isResolved = false;
      const timeout = setTimeout(() => {
        if (!isResolved) {
          isResolved = true;
          console.error(`Timeout after ${timeoutMs}ms running visualization script`);
          resolve({
            error: `Visualization timed out after ${timeoutMs/1000}s`,
            imagePath: ensureErrorImageExists(),
            description: 'The visualization took too long to generate.',
            clientSide: true
          });
        }
      }, timeoutMs);
      
      PythonShell.run(path.basename(scriptInfo.path), pyOptions, (err, results) => {
        clearTimeout(timeout);
        
        // Always clean up the temp file
        try { 
          if (fs.existsSync(tempCsvPath)) {
            fs.unlinkSync(tempCsvPath);
            tempFiles.delete(tempCsvPath);
            console.log(`Deleted temp file: ${tempCsvPath}`);
          }
        } catch (e) {
          console.error('Error deleting temp file:', e.message);
        }
        
        if (isResolved) return; // Already resolved by timeout
        isResolved = true;
        
        if (err) {
          console.error('Visualization error:', err);
          resolve({
            error: err.message,
            imagePath: ensureErrorImageExists(),
            description: 'Error generating visualization.',
            clientSide: true
          });
          return;
        }
        
        if (!results || results.length < 2) {
          console.error('Invalid response from visualization script:', results);
          resolve({
            error: 'Invalid response from visualization script',
            imagePath: ensureErrorImageExists(),
            description: 'The visualization script returned an invalid response.',
            clientSide: true
          });
          return;
        }
        
        // Process successful results
        const imagePath = results[0].trim();
        const description = results[1].trim();
        console.log(`Python script returned imagePath: ${imagePath}`);
        
        // Verify image path exists in public directory
        const fullImagePath = path.join(__dirname, '..', 'public', imagePath);
        console.log(`Checking if image exists at: ${fullImagePath}`);
        
        if (!fs.existsSync(fullImagePath)) {
          console.error(`Generated image not found at: ${fullImagePath}`);
          resolve({
            error: 'Generated image not found',
            imagePath: ensureErrorImageExists(),
            description: 'The visualization was generated but the image file is missing.',
            clientSide: true
          });
          return;
        }
        
        resolve({
          imagePath: imagePath,
          description: description,
          dataSource: 'ThingSpeak API',
          dataPoints: dataPoints
        });
      });
    });
    
    // Cache the successful result
    if (!vizResult.error) {
      visualizationCache.set(cacheKey, vizResult);
      return { success: true, data: vizResult };
    }
    
    return { 
      success: false, 
      error: vizResult.error,
      data: {
        imagePath: vizResult.imagePath || ensureErrorImageExists(),
        description: vizResult.description
      },
      clientSide: vizResult.clientSide 
    };
    
  } catch (error) {
    console.error('Error generating visualization:', error);
    
    // Remove process handlers to prevent memory leaks
    process.removeListener('exit', cleanupHandler);
    process.removeListener('SIGINT', exitHandler);
    process.removeListener('uncaughtException', exitHandler);
    
    return {
      success: false,
      error: error.message,
      data: {
        imagePath: ensureErrorImageExists(),
        description: 'Error generating visualization: ' + error.message
      },
      clientSide: true
    };
  } finally {
    // Clean up any remaining temp files
    cleanupHandler();
    
    // Remove process handlers
    process.removeListener('exit', cleanupHandler);
    process.removeListener('SIGINT', exitHandler);
    process.removeListener('uncaughtException', exitHandler);
  }
}

/**
 * Clear visualization cache
 */
function clearCache() {
  const cacheSize = visualizationCache.itemCount;
  visualizationCache.reset();
  return { cleared: true, items: cacheSize };
}

module.exports = {
  generateVisualization,
  ensureErrorImageExists,
  clearCache
};
